{
    "sourceFile": "src/pages/api/asset.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764337289216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764337289216,
            "name": "Commit-0",
            "content": "import type { APIRoute } from \"astro\";\nimport { API } from \"../../utils/api\";\n\nexport const GET: APIRoute = async ({ request, locals }) => {\n  API.init((locals.runtime as any).env.ORIGIN);\n\n  try {\n    const url = new URL(request.url);\n    const key = url.searchParams.get(\"key\");\n\n    if (!key) {\n      return API.error(\"Missing key\", request, 400);\n    }\n\n    const bucket = locals.runtime.env.CLOUD_FILES;\n    if (!bucket) {\n      return API.error(\"Cloud storage not configured\", request, 500);\n    }\n\n    const rangeHeader = request.headers.get(\"range\");\n    let rangeSpec: ByteRange | null = null;\n    let objectSize: number | undefined;\n\n    if (rangeHeader) {\n      const metadata = await bucket.head(key);\n      if (!metadata) {\n        return API.error(\"Not found\", request, 404);\n      }\n\n      rangeSpec = parseRangeHeader(rangeHeader, metadata.size);\n      objectSize = metadata.size;\n\n      if (!rangeSpec) {\n        return new Response(null, {\n          status: 416,\n          headers: API.withCorsHeaders(request, {\n            \"Accept-Ranges\": \"bytes\",\n            \"Content-Range\": `bytes */${metadata.size}`,\n          }),\n        });\n      }\n    }\n\n    const object = await bucket.get(\n      key,\n      rangeSpec\n        ? {\n            range: { offset: rangeSpec.start, length: rangeSpec.length },\n          }\n        : undefined,\n    );\n    if (!object) {\n      return API.error(\"Not found\", request, 404);\n    }\n\n    const data = await object.arrayBuffer();\n    const contentType = object.httpMetadata?.contentType || \"application/octet-stream\";\n    const headers = API.withCorsHeaders(request, {\n      \"Content-Type\": contentType,\n      \"Accept-Ranges\": \"bytes\",\n    });\n\n    if (rangeSpec) {\n      headers[\"Content-Length\"] = String(rangeSpec.length);\n      headers[\"Content-Range\"] = `bytes ${rangeSpec.start}-${rangeSpec.end}/${object.size}`;\n\n      return new Response(data, {\n        status: 206,\n        headers,\n      });\n    }\n\n    const totalSize = object.size ?? objectSize ?? data.byteLength;\n    headers[\"Content-Length\"] = String(totalSize);\n\n    return new Response(data, {\n      headers,\n    });\n  } catch (error) {\n    console.error(\"Asset retrieval error:\", error);\n    return API.error(\"Failed to retrieve asset\", request, 500);\n  }\n};\n\nexport const OPTIONS: APIRoute = async ({ request, locals }) => {\n  API.init((locals.runtime as any).env.ORIGIN);\n  return API.cors(request);\n};\n\ntype ByteRange = {\n  start: number;\n  end: number;\n  length: number;\n};\n\nconst parseRangeHeader = (value: string, size: number): ByteRange | null => {\n  if (!value) {\n    return null;\n  }\n\n  const trimmed = value.trim();\n  if (!trimmed.toLowerCase().startsWith(\"bytes=\")) {\n    return null;\n  }\n\n  const rangeValue = trimmed.substring(trimmed.indexOf(\"=\") + 1);\n  if (!rangeValue || rangeValue.includes(\",\")) {\n    return null;\n  }\n\n  const [startPart, endPart] = rangeValue.split(\"-\");\n  if (startPart === \"\" && endPart === \"\") {\n    return null;\n  }\n\n  let start = startPart ? Number(startPart) : Number.NaN;\n  let end = endPart ? Number(endPart) : Number.NaN;\n\n  if (Number.isNaN(start)) {\n    if (Number.isNaN(end) || end <= 0) {\n      return null;\n    }\n\n    const suffixLength = Math.min(end, size);\n    start = Math.max(size - suffixLength, 0);\n    end = size - 1;\n  } else {\n    if (start < 0 || start >= size) {\n      return null;\n    }\n\n    if (Number.isNaN(end) || end >= size) {\n      end = size - 1;\n    }\n  }\n\n  if (start > end) {\n    return null;\n  }\n\n  return {\n    start,\n    end,\n    length: end - start + 1,\n  };\n};\n"
        }
    ]
}