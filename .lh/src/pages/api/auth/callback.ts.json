{
    "sourceFile": "src/pages/api/auth/callback.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1764456537319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764458185289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,94 +3,95 @@\n import { AUTH_CONFIG } from '../../../lib/auth/config'\r\n import { createSession, decodeGoogleIdToken, isUserAllowed } from '../../../lib/auth/session'\r\n \r\n export const GET: APIRoute = async ({ url, cookies, redirect, locals }) => {\r\n-  const env = locals.runtime.env\r\n+    const env = locals.runtime.env\r\n \r\n-  // Get OAuth parameters from query string\r\n-  const code = url.searchParams.get('code')\r\n-  const state = url.searchParams.get('state')\r\n-  const error = url.searchParams.get('error')\r\n+    // Get OAuth parameters from query string\r\n+    const code = url.searchParams.get('code')\r\n+    const state = url.searchParams.get('state')\r\n+    const error = url.searchParams.get('error')\r\n \r\n-  // Handle OAuth errors from Google\r\n-  if (error) {\r\n-    console.error('OAuth error from Google:', error)\r\n-    return redirect('/ca/login?error=oauth_error')\r\n-  }\r\n+    // Handle OAuth errors from Google\r\n+    if (error) {\r\n+        console.error('OAuth error from Google:', error)\r\n+        return redirect('/ca/login?error=oauth_error')\r\n+    }\r\n \r\n-  if (!code || !state) {\r\n-    return redirect('/ca/login?error=missing_params')\r\n-  }\r\n+    if (!code || !state) {\r\n+        return redirect('/ca/login?error=missing_params')\r\n+    }\r\n \r\n-  // Get stored state and code verifier from cookies\r\n-  const storedState = cookies.get(AUTH_CONFIG.STATE_COOKIE)?.value\r\n-  const codeVerifier = cookies.get(AUTH_CONFIG.CODE_VERIFIER_COOKIE)?.value\r\n+    // Get stored state and code verifier from cookies\r\n+    const storedState = cookies.get(AUTH_CONFIG.STATE_COOKIE)?.value\r\n+    const codeVerifier = cookies.get(AUTH_CONFIG.CODE_VERIFIER_COOKIE)?.value\r\n \r\n-  // Clear OAuth cookies\r\n-  cookies.delete(AUTH_CONFIG.STATE_COOKIE, { path: '/ca' })\r\n-  cookies.delete(AUTH_CONFIG.CODE_VERIFIER_COOKIE, { path: '/ca' })\r\n+    // Clear OAuth cookies\r\n+    cookies.delete(AUTH_CONFIG.STATE_COOKIE, { path: '/ca' })\r\n+    cookies.delete(AUTH_CONFIG.CODE_VERIFIER_COOKIE, { path: '/ca' })\r\n \r\n-  // Verify state matches\r\n-  if (!storedState || state !== storedState) {\r\n-    console.error('State mismatch:', { received: state, stored: storedState })\r\n-    return redirect('/ca/login?error=state_mismatch')\r\n-  }\r\n+    // Verify state matches\r\n+    if (!storedState || state !== storedState) {\r\n+        console.error('State mismatch:', { received: state, stored: storedState })\r\n+        return redirect('/ca/login?error=state_mismatch')\r\n+    }\r\n \r\n-  if (!codeVerifier) {\r\n-    console.error('Missing code verifier')\r\n-    return redirect('/ca/login?error=missing_verifier')\r\n-  }\r\n+    if (!codeVerifier) {\r\n+        console.error('Missing code verifier')\r\n+        return redirect('/ca/login?error=missing_verifier')\r\n+    }\r\n \r\n-  // Get Google credentials\r\n-  const clientId = env.GOOGLE_CLIENT_ID\r\n-  const clientSecret = env.GOOGLE_CLIENT_SECRET\r\n-  const origin = env.ORIGIN\r\n-  const authSecret = env.AUTH_SECRET\r\n+    // Get Google credentials\r\n+    const clientId = env.GOOGLE_CLIENT_ID\r\n+    const clientSecret = env.GOOGLE_CLIENT_SECRET\r\n+    const origin = env.ORIGIN\r\n+    const authSecret = env.AUTH_SECRET\r\n \r\n-  if (!clientId || !clientSecret || !origin || !authSecret) {\r\n-    console.error('Missing environment configuration')\r\n-    return new Response(\r\n-      JSON.stringify({ error: 'Missing configuration' }),\r\n-      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n-    )\r\n-  }\r\n+    if (!clientId || !clientSecret || !origin || !authSecret) {\r\n+        console.error('Missing environment configuration')\r\n+        return new Response(\r\n+            JSON.stringify({ error: 'Missing configuration' }),\r\n+            { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n+        )\r\n+    }\r\n \r\n-  try {\r\n-    // Create Google provider and exchange code for tokens\r\n-    const google = createGoogleProvider(clientId, clientSecret, origin)\r\n-    const tokens = await google.validateAuthorizationCode(code, codeVerifier)\r\n+    try {\r\n+        // Create Google provider and exchange code for tokens\r\n+        const google = createGoogleProvider(clientId, clientSecret, origin)\r\n+        const tokens = await google.validateAuthorizationCode(code, codeVerifier)\r\n \r\n-    // Get ID token which contains user info\r\n-    const idToken = tokens.idToken()\r\n-    if (!idToken) {\r\n-      console.error('No ID token received')\r\n-      return redirect('/ca/login?error=no_id_token')\r\n-    }\r\n+        // Get ID token which contains user info\r\n+        const idToken = tokens.idToken()\r\n+        if (!idToken) {\r\n+            console.error('No ID token received')\r\n+            return redirect('/ca/login?error=no_id_token')\r\n+        }\r\n \r\n-    // Decode ID token to get user info\r\n-    const userInfo = decodeGoogleIdToken(idToken)\r\n-    if (!userInfo) {\r\n-      console.error('Failed to decode ID token')\r\n-      return redirect('/ca/login?error=invalid_id_token')\r\n-    }\r\n+        // Decode ID token to get user info\r\n+        const userInfo = decodeGoogleIdToken(idToken)\r\n+        if (!userInfo) {\r\n+            console.error('Failed to decode ID token')\r\n+            return redirect('/ca/login?error=invalid_id_token')\r\n+        }\r\n \r\n-    // Check if user is allowed (domain/email restrictions)\r\n-    const allowedDomains = env.ALLOWED_DOMAINS\r\n-    const allowedEmails = env.ALLOWED_EMAILS\r\n-    if (!isUserAllowed(userInfo.email, allowedDomains, allowedEmails)) {\r\n-      console.error('User not allowed:', userInfo.email)\r\n-      return redirect('/ca/login?error=unauthorized')\r\n-    }\r\n+        // Check if user is allowed (domain/email restrictions)\r\n+        const allowedDomains = env.ALLOWED_DOMAINS\r\n+        const allowedEmails = env.ALLOWED_EMAILS\r\n+        if (!isUserAllowed(userInfo.email, allowedDomains, allowedEmails)) {\r\n+            console.error('User not allowed:', userInfo.email)\r\n+            return redirect('/ca/login?error=unauthorized')\r\n+        }\r\n \r\n-    // Create session JWT\r\n-    const sessionToken = await createSession(userInfo, authSecret)\r\n+        // Create session JWT\r\n+        const sessionToken = await createSession(userInfo, authSecret)\r\n \r\n-    // Set session cookie\r\n-    cookies.set(AUTH_CONFIG.SESSION_COOKIE, sessionToken, AUTH_CONFIG.COOKIE_OPTIONS)\r\n+        // Set session cookie (for same-origin page requests)\r\n+        cookies.set(AUTH_CONFIG.SESSION_COOKIE, sessionToken, AUTH_CONFIG.COOKIE_OPTIONS)\r\n \r\n-    // Redirect to main app\r\n-    return redirect('/ca/')\r\n-  } catch (error) {\r\n-    console.error('OAuth callback error:', error)\r\n-    return redirect('/ca/login?error=auth_failed')\r\n-  }\r\n+        // Redirect to main app with token in URL fragment (for cross-origin API calls)\r\n+        // The client will extract this and store in localStorage\r\n+        return redirect(`/ca/?token=${sessionToken}#auth`)\r\n+    } catch (error) {\r\n+        console.error('OAuth callback error:', error)\r\n+        return redirect('/ca/login?error=auth_failed')\r\n+    }\r\n }\r\n"
                }
            ],
            "date": 1764456537319,
            "name": "Commit-0",
            "content": "import type { APIRoute } from 'astro'\r\nimport { createGoogleProvider } from '../../../lib/auth/arctic'\r\nimport { AUTH_CONFIG } from '../../../lib/auth/config'\r\nimport { createSession, decodeGoogleIdToken, isUserAllowed } from '../../../lib/auth/session'\r\n\r\nexport const GET: APIRoute = async ({ url, cookies, redirect, locals }) => {\r\n  const env = locals.runtime.env\r\n\r\n  // Get OAuth parameters from query string\r\n  const code = url.searchParams.get('code')\r\n  const state = url.searchParams.get('state')\r\n  const error = url.searchParams.get('error')\r\n\r\n  // Handle OAuth errors from Google\r\n  if (error) {\r\n    console.error('OAuth error from Google:', error)\r\n    return redirect('/ca/login?error=oauth_error')\r\n  }\r\n\r\n  if (!code || !state) {\r\n    return redirect('/ca/login?error=missing_params')\r\n  }\r\n\r\n  // Get stored state and code verifier from cookies\r\n  const storedState = cookies.get(AUTH_CONFIG.STATE_COOKIE)?.value\r\n  const codeVerifier = cookies.get(AUTH_CONFIG.CODE_VERIFIER_COOKIE)?.value\r\n\r\n  // Clear OAuth cookies\r\n  cookies.delete(AUTH_CONFIG.STATE_COOKIE, { path: '/ca' })\r\n  cookies.delete(AUTH_CONFIG.CODE_VERIFIER_COOKIE, { path: '/ca' })\r\n\r\n  // Verify state matches\r\n  if (!storedState || state !== storedState) {\r\n    console.error('State mismatch:', { received: state, stored: storedState })\r\n    return redirect('/ca/login?error=state_mismatch')\r\n  }\r\n\r\n  if (!codeVerifier) {\r\n    console.error('Missing code verifier')\r\n    return redirect('/ca/login?error=missing_verifier')\r\n  }\r\n\r\n  // Get Google credentials\r\n  const clientId = env.GOOGLE_CLIENT_ID\r\n  const clientSecret = env.GOOGLE_CLIENT_SECRET\r\n  const origin = env.ORIGIN\r\n  const authSecret = env.AUTH_SECRET\r\n\r\n  if (!clientId || !clientSecret || !origin || !authSecret) {\r\n    console.error('Missing environment configuration')\r\n    return new Response(\r\n      JSON.stringify({ error: 'Missing configuration' }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    )\r\n  }\r\n\r\n  try {\r\n    // Create Google provider and exchange code for tokens\r\n    const google = createGoogleProvider(clientId, clientSecret, origin)\r\n    const tokens = await google.validateAuthorizationCode(code, codeVerifier)\r\n\r\n    // Get ID token which contains user info\r\n    const idToken = tokens.idToken()\r\n    if (!idToken) {\r\n      console.error('No ID token received')\r\n      return redirect('/ca/login?error=no_id_token')\r\n    }\r\n\r\n    // Decode ID token to get user info\r\n    const userInfo = decodeGoogleIdToken(idToken)\r\n    if (!userInfo) {\r\n      console.error('Failed to decode ID token')\r\n      return redirect('/ca/login?error=invalid_id_token')\r\n    }\r\n\r\n    // Check if user is allowed (domain/email restrictions)\r\n    const allowedDomains = env.ALLOWED_DOMAINS\r\n    const allowedEmails = env.ALLOWED_EMAILS\r\n    if (!isUserAllowed(userInfo.email, allowedDomains, allowedEmails)) {\r\n      console.error('User not allowed:', userInfo.email)\r\n      return redirect('/ca/login?error=unauthorized')\r\n    }\r\n\r\n    // Create session JWT\r\n    const sessionToken = await createSession(userInfo, authSecret)\r\n\r\n    // Set session cookie\r\n    cookies.set(AUTH_CONFIG.SESSION_COOKIE, sessionToken, AUTH_CONFIG.COOKIE_OPTIONS)\r\n\r\n    // Redirect to main app\r\n    return redirect('/ca/')\r\n  } catch (error) {\r\n    console.error('OAuth callback error:', error)\r\n    return redirect('/ca/login?error=auth_failed')\r\n  }\r\n}\r\n"
        }
    ]
}