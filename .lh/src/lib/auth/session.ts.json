{
    "sourceFile": "src/lib/auth/session.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764456537395,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764456537395,
            "name": "Commit-0",
            "content": "import * as jose from 'jose'\r\nimport { AUTH_CONFIG, type SessionPayload } from './config'\r\n\r\n/**\r\n * Creates a signed JWT session token\r\n * @param payload - The session payload containing user info\r\n * @param secret - The secret key for signing\r\n * @returns The signed JWT string\r\n */\r\nexport async function createSession(\r\n    payload: SessionPayload,\r\n    secret: string\r\n): Promise<string> {\r\n    const secretKey = new TextEncoder().encode(secret)\r\n\r\n    const jwt = await new jose.SignJWT({\r\n        sub: payload.sub,\r\n        email: payload.email,\r\n        name: payload.name,\r\n        picture: payload.picture,\r\n    })\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setIssuer(AUTH_CONFIG.JWT_ISSUER)\r\n        .setAudience(AUTH_CONFIG.JWT_AUDIENCE)\r\n        .setExpirationTime(AUTH_CONFIG.JWT_EXPIRATION)\r\n        .sign(secretKey)\r\n\r\n    return jwt\r\n}\r\n\r\n/**\r\n * Verifies a JWT session token and returns the payload\r\n * @param token - The JWT token to verify\r\n * @param secret - The secret key for verification\r\n * @returns The session payload if valid, null otherwise\r\n */\r\nexport async function verifySession(\r\n    token: string | undefined,\r\n    secret: string\r\n): Promise<SessionPayload | null> {\r\n    if (!token) return null\r\n\r\n    try {\r\n        const secretKey = new TextEncoder().encode(secret)\r\n        const { payload } = await jose.jwtVerify(token, secretKey, {\r\n            issuer: AUTH_CONFIG.JWT_ISSUER,\r\n            audience: AUTH_CONFIG.JWT_AUDIENCE,\r\n        })\r\n\r\n        // Validate required fields\r\n        if (!payload.sub || !payload.email || !payload.name) {\r\n            return null\r\n        }\r\n\r\n        return {\r\n            sub: payload.sub as string,\r\n            email: payload.email as string,\r\n            name: payload.name as string,\r\n            picture: payload.picture as string | undefined,\r\n        }\r\n    } catch (error) {\r\n        // Token is invalid or expired\r\n        return null\r\n    }\r\n}\r\n\r\n/**\r\n * Decodes a Google ID token to extract user info\r\n * @param idToken - The Google ID token\r\n * @returns User info from the token\r\n */\r\nexport function decodeGoogleIdToken(idToken: string): {\r\n    sub: string\r\n    email: string\r\n    name: string\r\n    picture?: string\r\n} | null {\r\n    try {\r\n        // Decode the JWT without verification (Google already verified it)\r\n        const payload = jose.decodeJwt(idToken)\r\n\r\n        if (!payload.sub || !payload.email || !payload.name) {\r\n            return null\r\n        }\r\n\r\n        return {\r\n            sub: payload.sub as string,\r\n            email: payload.email as string,\r\n            name: payload.name as string,\r\n            picture: payload.picture as string | undefined,\r\n        }\r\n    } catch {\r\n        return null\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if a user is allowed based on email/domain allowlists\r\n * @param email - The user's email address\r\n * @param allowedDomains - Comma/space separated list of allowed domains\r\n * @param allowedEmails - Comma/space separated list of allowed emails\r\n * @returns True if user is allowed\r\n */\r\nexport function isUserAllowed(\r\n    email: string,\r\n    allowedDomains?: string,\r\n    allowedEmails?: string\r\n): boolean {\r\n    // If no restrictions, allow all\r\n    if (!allowedDomains && !allowedEmails) {\r\n        return true\r\n    }\r\n\r\n    const emailLower = email.toLowerCase()\r\n\r\n    // Check allowed emails\r\n    if (allowedEmails) {\r\n        const emails = allowedEmails.split(/[\\s,]+/).filter(Boolean).map(e => e.toLowerCase())\r\n        if (emails.includes(emailLower)) {\r\n            return true\r\n        }\r\n    }\r\n\r\n    // Check allowed domains\r\n    if (allowedDomains) {\r\n        const domains = allowedDomains.split(/[\\s,]+/).filter(Boolean).map(d => d.toLowerCase())\r\n        const userDomain = emailLower.split('@')[1]\r\n        if (userDomain && domains.includes(userDomain)) {\r\n            return true\r\n        }\r\n    }\r\n\r\n    return false\r\n}\r\n"
        }
    ]
}